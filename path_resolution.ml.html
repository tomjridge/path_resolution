<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>path_resolution.ml</title>
<meta name="generator" content="emacs 25.2.1; htmlfontify 0.21" />
<style type="text/css"><!-- 
body { font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  color: #000000;  background: #ffffff;  font-size: 10pt;  text-decoration: none; }
span.default   { font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  color: #000000;  background: #ffffff;  font-size: 10pt;  text-decoration: none; }
span.default a { font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  color: #000000;  background: #ffffff;  font-size: 10pt;  text-decoration: underline; }
span.builtin   { color: #483d8b;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: none; }
span.builtin a { color: #483d8b;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: underline; }
span.constant   { color: #008b8b;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: none; }
span.constant a { color: #008b8b;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: underline; }
span.constructor   { font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  color: #000000;  background: #ffffff;  font-size: 10pt;  text-decoration: none; }
span.constructor a { font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  color: #000000;  background: #ffffff;  font-size: 10pt;  text-decoration: underline; }
span.keyword   { color: #a020f0;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: none; }
span.keyword a { color: #a020f0;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: underline; }
span.string   { color: #8b2252;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: none; }
span.string a { color: #8b2252;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: underline; }
span.variable-name   { color: #a0522d;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: none; }
span.variable-name a { color: #a0522d;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: underline; }
span.function-name   { color: #0000ff;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: none; }
span.function-name a { color: #0000ff;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: underline; }
span.operator   { color: #a52a2a;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: none; }
span.operator a { color: #a52a2a;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: underline; }
span.type   { color: #228b22;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: none; }
span.type a { color: #228b22;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: underline; }
span.module   { color: #228b22;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: none; }
span.module a { color: #228b22;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: underline; }
span.governing   { color: #000000;  font-weight: 700;  font-family: Ubuntu Mono;  font-stretch: normal;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: none; }
span.governing a { color: #000000;  font-weight: 700;  font-family: Ubuntu Mono;  font-stretch: normal;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: underline; }
span.comment   { color: #b22222;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: none; }
span.comment a { color: #b22222;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: underline; }
span.comment-delimiter   { color: #b22222;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: none; }
span.comment-delimiter a { color: #b22222;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: underline; }
 --></style>

    <script type="text/javascript"><!--
  // this function is needed to work around
  // a bug in IE related to element attributes
  function hasClass(obj)
  {
      var result = false;
      if (obj.getAttributeNode("class") != null)
      {
          result = obj.getAttributeNode("class").value;
      }
      return result;
  }

  function stripe(id)
  {
      // the flag we'll use to keep track of
      // whether the current row is odd or even
      var even = false;

      // if arguments are provided to specify the colors
      // of the even & odd rows, then use the them;
      // otherwise use the following defaults:
      var evenColor = arguments[1] ? arguments[1] : "#fff";
      var oddColor  = arguments[2] ? arguments[2] : "#ddd";

      // obtain a reference to the desired table
      // if no such table exists, abort
      var table = document.getElementById(id);
      if (! table) { return; }

      // by definition, tables can have more than one tbody
      // element, so we'll have to get the list of child
      // &lt;tbody&gt;s
      var tbodies = table.getElementsByTagName("tbody");

      // and iterate through them...
      for (var h = 0; h < tbodies.length; h++)
      {
          // find all the &lt;tr&gt; elements...
          var trs = tbodies[h].getElementsByTagName("tr");

          // ... and iterate through them
          for (var i = 0; i < trs.length; i++)
          {
              // avoid rows that have a class attribute
              // or backgroundColor style
              if (! hasClass(trs[i]) &&
                  ! trs[i].style.backgroundColor)
              {
                  // get all the cells in this row...
                  var tds = trs[i].getElementsByTagName("td");

                  // and iterate through them...
                  for (var j = 0; j < tds.length; j++)
                  {
                      var mytd = tds[j];

                      // avoid cells that have a class attribute
                      // or backgroundColor style
                      if (! hasClass(mytd) &&
                          ! mytd.style.backgroundColor)
                      {
                          mytd.style.backgroundColor =
                            even ? evenColor : oddColor;
                      }
                  }
              }
              // flip from odd to even, or vice-versa
              even =  ! even;
          }
      }
  }

  function toggle_invis( name )
  {
      var filter =
        { acceptNode:
          function( node )
          { var classname = node.id;
            if( classname )
            { var classbase = classname.substr( 0, name.length );
              if( classbase == name ) { return NodeFilter.FILTER_ACCEPT; } }
            return NodeFilter.FILTER_SKIP; } };
      var walker = document.createTreeWalker( document.body           ,
                                              NodeFilter.SHOW_ELEMENT ,
                                              filter                  ,
                                              false                   );
      while( walker.nextNode() )
      {
          var e = walker.currentNode;
          if( e.style.display == "none" ) { e.style.display = "inline"; }
          else                            { e.style.display = "none";   }
      }
  }
--> </script>
  </head>
  <body onload="stripe('index'); return true;">

<pre><span class="comment-delimiter">(* </span><span class="comment">Simple prototype of a path resolution algorithm ------------------- </span><span class="comment-delimiter">*)</span>

<span class="comment-delimiter">(* </span><span class="comment">NOTE root is special! Not to be confused with </span><span class="comment">'</span><span class="comment">/</span><span class="comment">'</span><span class="comment"> appearing inside
   a path </span><span class="comment-delimiter">*)</span>

<span class="comment-delimiter">(* </span><span class="comment">

The SibylFS spec contains a description of path resolution,
parameterized for all the crazy behavioural differences (especially on
Mac). 

The following is an attempt to impose a comprehensible structure on
the real-world messiness. The algorithm below executes a version of
path resolution which takes account of the weirdnesses in real-world
behaviour. It is structured so that

- it &quot;naturally&quot; follows some notion of path resolution which is
  general enough to account for real-world behaviour
- it makes minimal commitments at each stage
- it tries to preserve complete information (of course, it drops bits
  of the path that have resolved uncontroversially)
- path resolution is broken down into stages
  - getting the &quot;next&quot; path component
  - updating the state and returning a result
  - finally, implementing path resolution recursively
- small steps are taken!
- what is happening is clear at each step
- the code is parameterized over the filesystem implementation
  (fs_ops)


At the moment, we do not take account of MAX_SYMLINK, MAX_PATH
etc. But these are easy to add.

NOTE one of the problems is the overloading of </span><span class="comment">'</span><span class="comment">/</span><span class="comment">'</span><span class="comment"> as a component
separator, the root (not so bad) and an indicator that a symlink
should be resolved

TODO:

- add MAX_SYMLINK and MAX_PATH

- construct a unix/windows path compatibility library based on this
  code

- add testing and code coverage

- test this code against SibylFS model and real-world traces; replace
  SibylFS model with this one

</span><span class="comment-delimiter">*)</span>


<span class="governing">open </span><span class="module">String_util</span>
<span class="governing">open </span><span class="module">Path_component</span>
<span class="governing">open </span><span class="module">Fs_ops</span>

<span class="comment-delimiter">(* </span><span class="comment">path resolution -------------------------------------------------- </span><span class="comment-delimiter">*)</span>

<span class="comment-delimiter">(* </span><span class="comment">

During path resolution we maintain a state:
- cwd, the current directory
- is_absolute, whether we are working with an absolute path
- path, the path itself, as a string (but without a leading slash,
  which is dealt with by is_absolute)

</span><span class="comment-delimiter">*)</span>
<span class="governing">type</span> <span class="type">'dir_id state</span> <span class="operator">=</span> <span class="operator">{</span>
  cwd<span class="operator">:</span> 'dir_id<span class="operator">;</span>
  is_absolute<span class="operator">:</span> bool<span class="operator">;</span>
  path<span class="operator">:</span> string<span class="operator">;</span>  
<span class="operator">}</span>


<span class="governing">let</span> <span class="function-name">is_finished</span><span class="variable-name"> s</span> <span class="operator">=</span> 
  <span class="operator">not</span> <span class="operator">(</span>s.is_absolute<span class="operator">)</span> <span class="operator">&amp;&amp;</span> <span class="operator">(</span>s.path <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="operator">)</span>


<span class="comment-delimiter">(* </span><span class="comment">

When we encounter a symlink, we need to get the symlink contents (a
string) and decide what to do next.

If the symlink starts with a slash, then we need to resolve an
absolute path, otherwise a relative path.

Essentially we then join the contents of the symlink with the
remainder of the path we are currently processing.

</span><span class="comment-delimiter">*)</span>
<span class="governing">let</span> <span class="function-name">state_from_symlink</span><span class="variable-name"> </span><span class="operator">~</span><span class="variable-name">cwd </span><span class="operator">~</span><span class="variable-name">symlink_contents </span><span class="operator">~</span><span class="variable-name">path</span> <span class="operator">=</span> 
  <span class="governing">let</span> <span class="variable-name">str</span> <span class="operator">=</span> symlink_contents <span class="governing">in</span>
  <span class="keyword">match</span> starts_with_slash str <span class="keyword">with</span>
  <span class="operator">|</span> <span class="constructor">Some</span> str' <span class="operator">-&gt;</span> 
    <span class="operator">{</span> cwd<span class="operator">;</span>
      is_absolute<span class="operator">=</span><span class="constant">true</span><span class="operator">;</span> 
      path<span class="operator">=(</span>str'<span class="operator">^</span><span class="string">&quot;/&quot;</span><span class="operator">^</span>path<span class="operator">)</span> <span class="operator">}</span>
  <span class="operator">|</span> <span class="constructor">None</span> <span class="operator">-&gt;</span> 
    <span class="operator">{</span> cwd<span class="operator">;</span>
      is_absolute<span class="operator">=</span><span class="constant">false</span><span class="operator">;</span>
      path<span class="operator">=</span>str<span class="operator">^</span><span class="string">&quot;/&quot;</span><span class="operator">^</span>path <span class="operator">}</span>



<span class="comment-delimiter">(* </span><span class="comment">Get the next component of the path. This function deals with strings, not state </span><span class="comment-delimiter">*)</span>
<span class="governing">let</span> <span class="function-name">get_next_comp</span><span class="variable-name"> s</span> <span class="operator">=</span> 
  <span class="keyword">assert</span> <span class="operator">(not</span> <span class="operator">(</span>is_finished s<span class="operator">));</span>
  <span class="keyword">match</span> s.is_absolute <span class="keyword">with</span>
  <span class="operator">|</span> <span class="constant">true</span> <span class="operator">-&gt;</span> <span class="constructor">`Root</span><span class="operator">,</span> <span class="operator">{</span>s <span class="keyword">with</span> is_absolute<span class="operator">=</span><span class="constant">false</span><span class="operator">}</span>
  <span class="operator">|</span> <span class="constant">false</span> <span class="operator">-&gt;</span>
    <span class="comment-delimiter">(* </span><span class="comment">we know that path &lt;&gt; &quot;&quot; </span><span class="comment-delimiter">*)</span>
    <span class="keyword">assert</span><span class="operator">(</span>s.path <span class="operator">&lt;&gt;</span> <span class="string">&quot;&quot;</span><span class="operator">);</span>
    split_on_first_slash s.path <span class="operator">|&gt;</span> <span class="keyword">fun</span> <span class="operator">(</span><span class="variable-name">comp</span><span class="operator">,</span><span class="variable-name">rest</span><span class="operator">)</span> <span class="operator">-&gt;</span>
    <span class="keyword">match</span> rest <span class="keyword">with</span> 
    <span class="operator">|</span> <span class="constructor">None</span> <span class="operator">-&gt;</span> <span class="constructor">`Finished_no_slash</span> comp<span class="operator">,</span> <span class="operator">{</span>s <span class="keyword">with</span> path<span class="operator">=</span><span class="string">&quot;&quot;</span><span class="operator">}</span>
    <span class="operator">|</span> <span class="constructor">Some</span> <span class="string">&quot;&quot;</span> <span class="operator">-&gt;</span> <span class="constructor">`Finished_slash</span> comp<span class="operator">,</span> <span class="operator">{</span>s <span class="keyword">with</span> path<span class="operator">=</span><span class="string">&quot;&quot;</span><span class="operator">}</span>
    <span class="operator">|</span> <span class="constructor">Some</span> rest <span class="operator">-&gt;</span> <span class="constructor">`Comp_with_slash</span> comp<span class="operator">,</span> <span class="operator">{</span>s <span class="keyword">with</span> path<span class="operator">=</span>rest<span class="operator">}</span>

<span class="governing">let</span> <span class="variable-name">_</span> <span class="operator">=</span> get_next_comp


<span class="comment-delimiter">(* </span><span class="comment">Step the path resolution state. This function interacts with the
   fs. </span><span class="comment-delimiter">*)</span>
<span class="governing">let</span> <span class="function-name">step</span><span class="variable-name"> </span><span class="operator">~</span><span class="variable-name">fs_ops s</span> <span class="operator">=</span>
  <span class="comment-delimiter">(* </span><span class="comment">get the next path component </span><span class="comment-delimiter">*)</span>
  s <span class="operator">|&gt;</span> get_next_comp <span class="operator">|&gt;</span> <span class="keyword">function</span>

  <span class="operator">|</span> <span class="constructor">`Root</span><span class="operator">,</span>s <span class="operator">-&gt;</span> <span class="constructor">`Ok</span> <span class="operator">{</span>s <span class="keyword">with</span> cwd<span class="operator">=</span>fs_ops.root<span class="operator">}</span>

  <span class="operator">|</span> <span class="constructor">`Finished_no_slash</span> c<span class="operator">,</span>s <span class="operator">-&gt;</span> 
    <span class="comment-delimiter">(* </span><span class="comment">No more path components left. It may be that the current
       component refers to a symlink, in which case we need to do more
       processing. This is dealt with elsewhere. </span><span class="comment-delimiter">*)</span>
    <span class="constructor">`Finished_no_slash</span> <span class="operator">(</span>c<span class="operator">,</span>s.cwd<span class="operator">)</span>  

  <span class="operator">|</span> <span class="constructor">`Finished_slash</span> c<span class="operator">,</span>s <span class="operator">-&gt;</span> 
    <span class="comment-delimiter">(* </span><span class="comment">Again, c may be a symlink </span><span class="comment-delimiter">*)</span>
    <span class="constructor">`Finished_slash</span> <span class="operator">(</span>c<span class="operator">,</span>s.cwd<span class="operator">)</span>

  <span class="operator">|</span> <span class="constructor">`Comp_with_slash</span> c<span class="operator">,</span>s <span class="operator">-&gt;</span> 
    <span class="comment-delimiter">(* </span><span class="comment">

We have not finished, so there are more components to process. 

These may just be extra trailing slashes. In addition, the current
entry may be missing. An example where both happen is: /a/b//// where
b is a missing target of a dir rename. This case is likely acceptable.

On the other hand we may have a path /a/b/x/y/z, where again b is
missing. This is likely an error.

NOTE there is the question where &quot;&quot; should be silently ignored, or
actually passed to fs_ops to resolve

    </span><span class="comment-delimiter">*)</span>
    fs_ops.resolve_comp s.cwd c <span class="operator">|&gt;</span> <span class="keyword">function</span>
    <span class="operator">|</span> <span class="constructor">File</span> fid <span class="operator">-&gt;</span> 
      <span class="comment-delimiter">(* </span><span class="comment">NOTE we have something like f.txt/// or f.txt/a/b; f.txt/ is
         actually treated as valid on some platforms, especially if
         f.txt is a symlink to a file, so that the trailing slash
         means &quot;follow symlink&quot; FIXME add a flag for this </span><span class="comment-delimiter">*)</span>
      <span class="constructor">`Error</span> <span class="operator">(</span><span class="constructor">`File_followed_by_slash_etc</span> <span class="operator">(</span>s<span class="operator">,</span>c<span class="operator">,</span>fid<span class="operator">))</span>

    <span class="operator">|</span> <span class="constructor">Dir</span> d <span class="operator">-&gt;</span> <span class="constructor">`Ok</span> <span class="operator">{</span>s <span class="keyword">with</span> cwd<span class="operator">=</span>d<span class="operator">}</span>

    <span class="operator">|</span> <span class="constructor">Sym</span> str <span class="operator">-&gt;</span> <span class="operator">(</span>
        <span class="comment-delimiter">(* </span><span class="comment">We have something like symlink// or symlink/x/y/z; in the
           first case, we force the follow of the symlink FIXME some
           platforms do not do this, so parameterize </span><span class="comment-delimiter">*)</span>
        <span class="constructor">`Ok</span> <span class="operator">(</span>state_from_symlink <span class="constant">~cwd</span><span class="operator">:</span>s.cwd <span class="constant">~symlink_contents</span><span class="operator">:</span>str <span class="constant">~path</span><span class="operator">:</span>s.path<span class="operator">))</span>
    <span class="operator">|</span> <span class="constructor">Missing</span> <span class="operator">-&gt;</span> 
      <span class="comment-delimiter">(* </span><span class="comment">NOTE missing/ is ok if the target is a missing directory </span><span class="comment-delimiter">*)</span>
      <span class="comment-delimiter">(* </span><span class="comment">This may or may not be valid. So return all that we know at
         this point; path may be empty, or eg &quot;///&quot; so this could be a
         valid path </span><span class="comment-delimiter">*)</span>
      <span class="constructor">`Missing_slash</span><span class="operator">(</span>c<span class="operator">,</span>s<span class="operator">)</span>

<span class="governing">let</span> <span class="variable-name">_</span> <span class="operator">=</span> step


<span class="comment-delimiter">(* </span><span class="comment">Resolve all but the last component; not used by the main `resolve`
   function </span><span class="comment-delimiter">*)</span>
<span class="governing">let</span> <span class="function-name">resolve_butlast</span><span class="variable-name"> </span><span class="operator">~</span><span class="variable-name">fs_ops </span><span class="operator">~</span><span class="variable-name">cwd</span> <span class="operator">=</span> 
  <span class="governing">let</span> <span class="variable-name">step</span> <span class="operator">=</span> step <span class="operator">~</span>fs_ops <span class="governing">in</span>
  <span class="governing">let</span> <span class="governing">rec</span> <span class="function-name">f</span><span class="variable-name"> s</span> <span class="operator">=</span> 
    <span class="keyword">assert</span> <span class="operator">(not</span> <span class="operator">(</span>is_finished s<span class="operator">));</span>
    step s <span class="operator">|&gt;</span> <span class="keyword">function</span>
    <span class="operator">|</span> <span class="constructor">`Ok</span> s <span class="operator">-&gt;</span> f s
    <span class="operator">|</span> <span class="constructor">`Finished_no_slash</span> x <span class="operator">-&gt;</span> <span class="constructor">`Finished_no_slash</span> x
    <span class="operator">|</span> <span class="constructor">`Finished_slash</span> x <span class="operator">-&gt;</span> <span class="constructor">`Finished_slash</span> x
    <span class="operator">|</span> <span class="constructor">`Error</span> e <span class="operator">-&gt;</span> <span class="constructor">`Error</span> e
    <span class="operator">|</span> <span class="constructor">`Missing_slash</span> x <span class="operator">-&gt;</span> <span class="constructor">`Missing_slash</span> x
  <span class="governing">in</span>  
  <span class="keyword">fun</span> <span class="variable-name">s</span> <span class="operator">-&gt;</span>
    <span class="keyword">match</span> starts_with_slash s <span class="keyword">with</span>
    <span class="operator">|</span> <span class="constructor">None</span> <span class="operator">-&gt;</span> f <span class="operator">{</span> cwd<span class="operator">;</span> is_absolute<span class="operator">=</span><span class="constant">false</span><span class="operator">;</span> path<span class="operator">=</span>s <span class="operator">}</span>
    <span class="operator">|</span> <span class="constructor">Some</span> path <span class="operator">-&gt;</span> f <span class="operator">{</span> cwd<span class="operator">;</span> is_absolute<span class="operator">=</span><span class="constant">true</span><span class="operator">;</span> path <span class="operator">}</span>


<span class="comment-delimiter">(* </span><span class="comment">NOTE that the last component is not resolved; follow_last_symlink
   etc can be done as another step </span><span class="comment-delimiter">*)</span>
<span class="governing">let</span> <span class="variable-name">_</span> <span class="operator">:</span> <span class="type">
  </span><span class="constant">fs_ops</span><span class="operator">:</span><span class="type"> </span><span class="operator">(</span><span class="type">'file_id</span><span class="operator">,</span><span class="type">'dir_id</span><span class="operator">)</span><span class="type"> fs_ops </span><span class="operator">-&gt;</span><span class="type"> </span><span class="constant">cwd</span><span class="operator">:</span><span class="type">'dir_id </span><span class="operator">-&gt;</span><span class="type"> string </span><span class="operator">-&gt;</span><span class="type">
  </span><span class="operator">[&gt;</span><span class="type"> </span><span class="constructor">`Error</span><span class="type"> </span><span class="keyword">of</span><span class="type"> </span><span class="operator">[&gt;</span><span class="type"> </span><span class="constructor">`File_followed_by_slash_etc</span><span class="type"> </span><span class="keyword">of</span><span class="type"> 'dir_id state </span><span class="operator">*</span><span class="type"> comp_ </span><span class="operator">*</span><span class="type"> 'file_id </span><span class="operator">]</span><span class="type">
  </span><span class="operator">|</span><span class="type"> </span><span class="constructor">`Finished_no_slash</span><span class="type"> </span><span class="keyword">of</span><span class="type"> comp_ </span><span class="operator">*</span><span class="type"> 'dir_id
  </span><span class="operator">|</span><span class="type"> </span><span class="constructor">`Finished_slash</span><span class="type"> </span><span class="keyword">of</span><span class="type"> comp_ </span><span class="operator">*</span><span class="type"> 'dir_id
  </span><span class="operator">|</span><span class="type"> </span><span class="constructor">`Missing_slash</span><span class="type"> </span><span class="keyword">of</span><span class="type"> comp_ </span><span class="operator">*</span><span class="type"> 'dir_id state </span><span class="operator">]</span><span class="type">
  </span><span class="operator">=</span> resolve_butlast

<span class="operator">;;</span>

<span class="comment-delimiter">(* </span><span class="comment">

NOTE `resolve_butlast` is cumbersome to use if you want information
about the last component, and want to deal with `follow_last_symlink`
(you have to call `resolve_butlast` repeatedly, possibly in
conjunction with calling fs_ops.resolve_comp).

The next piece of code `resolve` returns info on the last component,
but NOTE there are several ways implementations commonly differ in
behaviour

</span><span class="comment-delimiter">*)</span>

<span class="governing">let</span> <span class="function-name">resolve</span><span class="variable-name"> </span><span class="operator">~</span><span class="variable-name">fs_ops </span><span class="operator">~</span><span class="variable-name">follow_last_symlink </span><span class="operator">~</span><span class="variable-name">cwd</span> <span class="operator">=</span> 
  <span class="governing">let</span> <span class="variable-name">step</span> <span class="operator">=</span> step <span class="operator">~</span>fs_ops <span class="governing">in</span>
  <span class="governing">let</span> <span class="governing">rec</span> <span class="function-name">f</span><span class="variable-name"> s</span> <span class="operator">=</span> 
    <span class="keyword">assert</span> <span class="operator">(not</span> <span class="operator">(</span>is_finished s<span class="operator">));</span>
    step s <span class="operator">|&gt;</span> <span class="keyword">function</span>
    <span class="operator">|</span> <span class="constructor">`Ok</span> s <span class="operator">-&gt;</span> f s

    <span class="operator">|</span> <span class="constructor">`Finished_no_slash</span> <span class="operator">(</span>comp<span class="operator">,</span>dir<span class="operator">)</span> <span class="operator">-&gt;</span> <span class="operator">(</span>
        <span class="comment-delimiter">(* </span><span class="comment">Cases where there is no trailing slash </span><span class="comment-delimiter">*)</span>
        fs_ops.resolve_comp dir comp <span class="operator">|&gt;</span> <span class="keyword">function</span>
        <span class="operator">|</span> <span class="constructor">File</span> fid <span class="operator">-&gt;</span> <span class="constructor">`Finished_no_slash_file</span> <span class="operator">(</span>dir<span class="operator">,</span>comp<span class="operator">,</span>fid<span class="operator">)</span>
        <span class="operator">|</span> <span class="constructor">Dir</span> d <span class="operator">-&gt;</span> <span class="constructor">`Finished_no_slash_dir</span> <span class="operator">(</span>dir<span class="operator">,</span>comp<span class="operator">,</span>d<span class="operator">)</span>
        <span class="operator">|</span> <span class="constructor">Sym</span> str <span class="operator">-&gt;</span> <span class="operator">(</span>
            <span class="comment-delimiter">(* </span><span class="comment">A symlink without a trailing slash </span><span class="comment-delimiter">*)</span>
            <span class="keyword">match</span> follow_last_symlink <span class="keyword">with</span>
            <span class="operator">|</span> <span class="constant">true</span> <span class="operator">-&gt;</span> 
              state_from_symlink <span class="constant">~cwd</span><span class="operator">:</span>dir <span class="constant">~symlink_contents</span><span class="operator">:</span>str <span class="constant">~path</span><span class="operator">:</span><span class="string">&quot;&quot;</span> <span class="operator">|&gt;</span> f
            <span class="operator">|</span> <span class="constant">false</span> <span class="operator">-&gt;</span> 
              <span class="constructor">`Finished_no_slash_symlink</span> <span class="operator">(</span>dir<span class="operator">,</span>comp<span class="operator">,</span>str<span class="operator">))</span>
        <span class="operator">|</span> <span class="constructor">Missing</span> <span class="operator">-&gt;</span> <span class="constructor">`Missing_finished_no_slash</span><span class="operator">(</span>dir<span class="operator">,</span>comp<span class="operator">))</span>

    <span class="operator">|</span> <span class="constructor">`Finished_slash</span> <span class="operator">(</span>comp<span class="operator">,</span>dir<span class="operator">)</span> <span class="operator">-&gt;</span> <span class="operator">(</span>
        <span class="comment-delimiter">(* </span><span class="comment">Cases where there is a trailing slash </span><span class="comment-delimiter">*)</span>
        fs_ops.resolve_comp dir comp <span class="operator">|&gt;</span> <span class="keyword">function</span>
        <span class="operator">|</span> <span class="constructor">File</span> fid <span class="operator">-&gt;</span> 
          <span class="comment-delimiter">(* </span><span class="comment">NOTE potentially an error </span><span class="comment-delimiter">*)</span>
          <span class="constructor">`Finished_slash_file</span> <span class="operator">(</span>dir<span class="operator">,</span>comp<span class="operator">,</span>fid<span class="operator">)</span>

        <span class="operator">|</span> <span class="constructor">Dir</span> d <span class="operator">-&gt;</span> 
          <span class="comment-delimiter">(* </span><span class="comment">Never (?) an error </span><span class="comment-delimiter">*)</span>
          <span class="constructor">`Finished_slash_dir</span> <span class="operator">(</span>dir<span class="operator">,</span>comp<span class="operator">,</span>d<span class="operator">)</span>

        <span class="operator">|</span> <span class="constructor">Sym</span> str <span class="operator">-&gt;</span> <span class="operator">(</span>
            <span class="comment-delimiter">(* </span><span class="comment">NOTE there is a trailing slash; FIXME the following
               line doesn't hold on all platforms; parameterize </span><span class="comment-delimiter">*)</span>
            <span class="governing">let</span> <span class="variable-name">follow_last_symlink</span> <span class="operator">=</span> <span class="constant">true</span> <span class="governing">in</span>  <span class="comment-delimiter">(* </span><span class="comment">because trailing slash </span><span class="comment-delimiter">*)</span>
            <span class="keyword">match</span> follow_last_symlink <span class="keyword">with</span>
            <span class="operator">|</span> <span class="constant">true</span> <span class="operator">-&gt;</span> 
              state_from_symlink <span class="constant">~cwd</span><span class="operator">:</span>dir <span class="constant">~symlink_contents</span><span class="operator">:</span>str <span class="constant">~path</span><span class="operator">:</span><span class="string">&quot;&quot;</span> <span class="operator">|&gt;</span> f
            <span class="operator">|</span> <span class="constant">false</span> <span class="operator">-&gt;</span> 
              <span class="comment-delimiter">(* </span><span class="comment">NOTE this case only occurs if the follow_last_symlink
                 is false - which may occur on some platforms FIXME </span><span class="comment-delimiter">*)</span>
              <span class="comment-delimiter">(* </span><span class="comment">`Finished_slash_symlink (dir,comp,str) </span><span class="comment-delimiter">*)</span>
              <span class="builtin">failwith</span> <span class="string">&quot;impossible at the moment&quot;</span><span class="operator">)</span>

        <span class="operator">|</span> <span class="constructor">Missing</span> <span class="operator">-&gt;</span> <span class="constructor">`Missing_finished_slash</span><span class="operator">(</span>dir<span class="operator">,</span>comp<span class="operator">))</span>

    <span class="operator">|</span> <span class="constructor">`Error</span> e <span class="operator">-&gt;</span> <span class="constructor">`Error</span> e

    <span class="operator">|</span> <span class="constructor">`Missing_slash</span> <span class="operator">(</span>comp<span class="operator">,</span>s<span class="operator">)</span> <span class="operator">-&gt;</span> 
      <span class="comment-delimiter">(* </span><span class="comment">NOTE that there may well be further stuff to resolve in
         s.path, likely indicating an error; this is dealt with
         later </span><span class="comment-delimiter">*)</span>
      <span class="constructor">`Missing_slash</span> <span class="operator">(</span>comp<span class="operator">,</span>s<span class="operator">)</span>
  <span class="governing">in</span>  
  <span class="keyword">fun</span> <span class="variable-name">s</span> <span class="operator">-&gt;</span>
    <span class="keyword">match</span> starts_with_slash s <span class="keyword">with</span>
    <span class="operator">|</span> <span class="constructor">None</span> <span class="operator">-&gt;</span> f <span class="operator">{</span> cwd<span class="operator">;</span> is_absolute<span class="operator">=</span><span class="constant">false</span><span class="operator">;</span> path<span class="operator">=</span>s <span class="operator">}</span>
    <span class="operator">|</span> <span class="constructor">Some</span> path <span class="operator">-&gt;</span> f <span class="operator">{</span> cwd<span class="operator">;</span> is_absolute<span class="operator">=</span><span class="constant">true</span><span class="operator">;</span> path <span class="operator">}</span>

<span class="governing">let</span> <span class="function-name">_</span> <span class="operator">:</span> 
<span class="constant">fs_ops</span><span class="operator">:</span> <span class="operator">(</span>'file_id<span class="operator">,</span>'dir_id<span class="operator">)</span> fs_ops <span class="operator">-&gt;</span>
<span class="constant">follow_last_symlink</span><span class="operator">:</span>bool <span class="operator">-&gt;</span>
<span class="constant">cwd</span><span class="operator">:</span>'dir_id <span class="operator">-&gt;</span>
string <span class="operator">-&gt;</span>
<span class="operator">[&gt;</span> <span class="constructor">`Error</span> <span class="keyword">of</span> <span class="operator">[&gt;</span> <span class="constructor">`File_followed_by_slash_etc</span> <span class="keyword">of</span> 'dir_id state <span class="operator">*</span> comp_ <span class="operator">*</span> 'file_id <span class="operator">]</span>
 <span class="operator">|</span> <span class="constructor">`Finished_no_slash_dir</span> <span class="keyword">of</span> 'dir_id <span class="operator">*</span> comp_ <span class="operator">*</span> 'dir_id
 <span class="operator">|</span> <span class="constructor">`Finished_no_slash_file</span> <span class="keyword">of</span> 'dir_id <span class="operator">*</span> comp_ <span class="operator">*</span> 'file_id
 <span class="operator">|</span> <span class="constructor">`Finished_no_slash_symlink</span> <span class="keyword">of</span> 'dir_id <span class="operator">*</span> comp_ <span class="operator">*</span> string
 <span class="operator">|</span> <span class="constructor">`Finished_slash_dir</span> <span class="keyword">of</span> 'dir_id <span class="operator">*</span> comp_ <span class="operator">*</span> 'dir_id
 <span class="operator">|</span> <span class="constructor">`Finished_slash_file</span> <span class="keyword">of</span> 'dir_id <span class="operator">*</span> comp_ <span class="operator">*</span> 'file_id
 <span class="operator">|</span> <span class="constructor">`Finished_slash_symlink</span> <span class="keyword">of</span> 'dir_id <span class="operator">*</span> comp_ <span class="operator">*</span> string
 <span class="operator">|</span> <span class="constructor">`Missing_slash</span> <span class="keyword">of</span> comp_ <span class="operator">*</span> 'dir_id state
 <span class="operator">|</span> <span class="constructor">`Missing_finished_no_slash</span> <span class="keyword">of</span> 'dir_id <span class="operator">*</span> comp_
 <span class="operator">|</span> <span class="constructor">`Missing_finished_slash</span> <span class="keyword">of</span> 'dir_id <span class="operator">*</span> comp_ <span class="operator">]</span>
<span class="operator">=</span> resolve


<span class="comment-delimiter">(* </span><span class="comment">the above has a lot of cases; we pick out some commonalities to
   simplify subsequent case splitting </span><span class="comment-delimiter">*)</span>

<span class="governing">module</span> <span class="module">Simplified_result</span> <span class="operator">=</span> <span class="governing">struct</span>
  <span class="governing">type</span> <span class="operator">(</span><span class="type">'file_id</span><span class="operator">,</span><span class="type">'dir_id</span><span class="operator">)</span><span class="type"> simplified_result'</span> <span class="operator">=</span> <span class="constructor">File</span> <span class="keyword">of</span> 'file_id <span class="operator">|</span> <span class="constructor">Dir</span> <span class="keyword">of</span> 'dir_id <span class="operator">|</span> <span class="constructor">Sym</span> <span class="keyword">of</span> string <span class="operator">|</span> <span class="constructor">Missing</span>
  <span class="governing">type</span> <span class="operator">(</span><span class="type">'file_id</span><span class="operator">,</span><span class="type">'dir_id</span><span class="operator">)</span><span class="type"> simplified_result</span> <span class="operator">=</span> 
    <span class="operator">{</span> parent_id<span class="operator">:</span> 'dir_id<span class="operator">;</span> comp<span class="operator">:</span> comp_<span class="operator">;</span> result<span class="operator">:</span> <span class="operator">(</span>'file_id<span class="operator">,</span>'dir_id<span class="operator">)</span> simplified_result'<span class="operator">;</span> trailing_slash<span class="operator">:</span>bool <span class="operator">}</span>
<span class="governing">end</span>
<span class="governing">include</span> <span class="module">Simplified_result</span>

<span class="governing">let</span> <span class="function-name">resolve_simplified</span><span class="variable-name"> </span><span class="operator">~</span><span class="variable-name">fs_ops </span><span class="operator">~</span><span class="variable-name">follow_last_symlink </span><span class="operator">~</span><span class="variable-name">cwd s</span> <span class="operator">=</span> 
  resolve <span class="operator">~</span>fs_ops <span class="operator">~</span>follow_last_symlink <span class="operator">~</span>cwd s <span class="operator">|&gt;</span> <span class="keyword">function</span>
  <span class="operator">|</span> <span class="constructor">`Error</span> e <span class="operator">-&gt;</span> <span class="constructor">Error</span> e

  <span class="operator">|</span> <span class="constructor">`Finished_no_slash_dir</span> <span class="operator">(</span>parent_id<span class="operator">,</span>comp<span class="operator">,</span>did<span class="operator">)</span> <span class="operator">-&gt;</span> <span class="constructor">Ok</span> <span class="module">Simplified_result.</span><span class="operator">{</span> 
      parent_id<span class="operator">;</span> comp<span class="operator">;</span> result<span class="operator">=(</span><span class="constructor">Dir</span> did<span class="operator">);</span> trailing_slash<span class="operator">=</span><span class="constant">false</span> <span class="operator">}</span>

 <span class="operator">|</span> <span class="constructor">`Finished_no_slash_file</span> <span class="operator">(</span>parent_id<span class="operator">,</span>comp<span class="operator">,</span>fid<span class="operator">)</span> <span class="operator">-&gt;</span> <span class="constructor">Ok</span> <span class="module">Simplified_result.</span><span class="operator">{</span>
      parent_id<span class="operator">;</span> comp<span class="operator">;</span> result<span class="operator">=(</span><span class="constructor">File</span> fid<span class="operator">);</span> trailing_slash<span class="operator">=</span><span class="constant">false</span> <span class="operator">}</span>       

 <span class="operator">|</span> <span class="constructor">`Finished_no_slash_symlink</span> <span class="operator">(</span>parent_id<span class="operator">,</span>comp<span class="operator">,</span>str<span class="operator">)</span> <span class="operator">-&gt;</span> <span class="constructor">Ok</span> <span class="module">Simplified_result.</span><span class="operator">{</span>
     parent_id<span class="operator">;</span> comp<span class="operator">;</span> result<span class="operator">=(</span><span class="constructor">Sym</span> str<span class="operator">);</span> trailing_slash<span class="operator">=</span><span class="constant">false</span> <span class="operator">}</span>       

 <span class="operator">|</span> <span class="constructor">`Finished_slash_dir</span> <span class="operator">(</span>parent_id<span class="operator">,</span>comp<span class="operator">,</span>did<span class="operator">)</span> <span class="operator">-&gt;</span> <span class="constructor">Ok</span> <span class="module">Simplified_result.</span><span class="operator">{</span> 
     parent_id<span class="operator">;</span> comp<span class="operator">;</span> result<span class="operator">=(</span><span class="constructor">Dir</span> did<span class="operator">);</span> trailing_slash<span class="operator">=</span><span class="constant">true</span> <span class="operator">}</span>

 <span class="operator">|</span> <span class="constructor">`Finished_slash_file</span> <span class="operator">(</span>parent_id<span class="operator">,</span>comp<span class="operator">,</span>fid<span class="operator">)</span> <span class="operator">-&gt;</span> 
   <span class="comment-delimiter">(* </span><span class="comment">NOTE this is often an error FIXME include a further layer to
      capture these cases? </span><span class="comment-delimiter">*)</span>
   <span class="constructor">Ok</span> <span class="module">Simplified_result.</span><span class="operator">{</span>
       parent_id<span class="operator">;</span> comp<span class="operator">;</span> result<span class="operator">=(</span><span class="constructor">File</span> fid<span class="operator">);</span> trailing_slash<span class="operator">=</span><span class="constant">true</span> <span class="operator">}</span>

 <span class="operator">|</span> <span class="constructor">`Finished_slash_symlink</span> <span class="operator">(</span>parent_id<span class="operator">,</span>comp<span class="operator">,</span>str<span class="operator">)</span> <span class="operator">-&gt;</span> 
   <span class="comment-delimiter">(* </span><span class="comment">NOTE the trailing slash typically forces the symlink to be
      followed </span><span class="comment-delimiter">*)</span>
   <span class="constructor">Ok</span> <span class="module">Simplified_result.</span><span class="operator">{</span>
       parent_id<span class="operator">;</span> comp<span class="operator">;</span> result<span class="operator">=(</span><span class="constructor">Sym</span> str<span class="operator">);</span> trailing_slash<span class="operator">=</span><span class="constant">true</span> <span class="operator">}</span>

 <span class="operator">|</span> <span class="constructor">`Missing_slash</span> <span class="operator">(</span>comp<span class="operator">,</span>s<span class="operator">)</span> <span class="operator">-&gt;</span> <span class="operator">(</span>
     <span class="comment-delimiter">(*</span><span class="comment">

We have a missing component followed by further stuff in s.path. 

We distinguish between the cases where there are trailing slashes only
in s.path, and where there is something other than a trailing
slash.

NOTE there may be other choices here

</span><span class="comment-delimiter">*)</span>

   <span class="keyword">assert</span><span class="operator">(</span>s.is_absolute <span class="operator">=</span> <span class="constant">false</span><span class="operator">);</span>
   <span class="governing">let</span> <span class="variable-name">remaining</span> <span class="operator">=</span> s.path <span class="governing">in</span>
   <span class="comment-delimiter">(* </span><span class="comment">check if all slashes </span><span class="comment-delimiter">*)</span>
   <span class="keyword">match</span> all_slashes remaining <span class="keyword">with</span>
   <span class="operator">|</span> <span class="constant">true</span> <span class="operator">-&gt;</span> 
     <span class="comment-delimiter">(* </span><span class="comment">NOTE the component is missing, and the unprocessed path suffix
        contains only slashes; typically this would represent a target of
        a rename of a directory, but some platforms allow this for file
        renames etc; we return an `Ok`, but be aware that this may be an
        error with some platforms and some syscalls </span><span class="comment-delimiter">*)</span>
     <span class="constructor">Ok</span> <span class="module">Simplified_result.</span><span class="operator">{</span>
       parent_id<span class="operator">=</span>s.cwd<span class="operator">;</span> comp<span class="operator">;</span> result<span class="operator">=</span><span class="constructor">Missing</span><span class="operator">;</span> trailing_slash<span class="operator">=</span><span class="constant">true</span> <span class="operator">}</span>

   <span class="operator">|</span> <span class="constant">false</span> <span class="operator">-&gt;</span> 
     <span class="comment-delimiter">(* </span><span class="comment">This is an error case eg /a/b/missing/some/more/stuff </span><span class="comment-delimiter">*)</span>
     <span class="constructor">Error</span> <span class="operator">(</span><span class="constructor">`Missing_slash</span> <span class="operator">(</span>comp<span class="operator">,</span>s.cwd<span class="operator">,</span>remaining<span class="operator">)))</span>

 <span class="operator">|</span> <span class="constructor">`Missing_finished_no_slash</span> <span class="operator">(</span>parent_id<span class="operator">,</span>comp<span class="operator">)</span> <span class="operator">-&gt;</span> <span class="constructor">Ok</span> <span class="module">Simplified_result.</span><span class="operator">{</span>
     parent_id<span class="operator">;</span> comp<span class="operator">;</span> result<span class="operator">=</span><span class="constructor">Missing</span><span class="operator">;</span> trailing_slash<span class="operator">=</span><span class="constant">false</span> <span class="operator">}</span>
     
 <span class="operator">|</span> <span class="constructor">`Missing_finished_slash</span> <span class="operator">(</span>parent_id<span class="operator">,</span>comp<span class="operator">)</span> <span class="operator">-&gt;</span> <span class="constructor">Ok</span> <span class="module">Simplified_result.</span><span class="operator">{</span>
     parent_id<span class="operator">;</span> comp<span class="operator">;</span> result<span class="operator">=</span><span class="constructor">Missing</span><span class="operator">;</span> trailing_slash<span class="operator">=</span><span class="constant">false</span> <span class="operator">}</span>

<span class="operator">;;</span>

<span class="governing">let</span> <span class="function-name">_</span> <span class="operator">:</span>
<span class="constant">fs_ops</span><span class="operator">:(</span>'file_id<span class="operator">,</span>'dir_id<span class="operator">)</span> fs_ops <span class="operator">-&gt;</span>
follow_last_symlink<span class="operator">:</span>bool <span class="operator">-&gt;</span>
<span class="constant">cwd</span><span class="operator">:</span>'dir_id <span class="operator">-&gt;</span>
string <span class="operator">-&gt;</span>
<span class="operator">((</span>'file_id<span class="operator">,</span>'dir_id<span class="operator">)</span> <span class="module">Simplified_result.</span>simplified_result<span class="operator">,</span>
 <span class="operator">[&gt;</span> <span class="constructor">`File_followed_by_slash_etc</span> <span class="keyword">of</span> 'dir_id state <span class="operator">*</span> comp_ <span class="operator">*</span> 'file_id  <span class="comment-delimiter">(* </span><span class="comment">FIXME clarify further? </span><span class="comment-delimiter">*)</span>
  <span class="operator">|</span> <span class="constructor">`Missing_slash</span> <span class="keyword">of</span> comp_ <span class="operator">*</span> 'dir_id <span class="operator">*</span> string <span class="operator">])</span> result
<span class="operator">=</span> resolve_simplified

<span class="operator">;;</span>


</pre>

 </body>
</html>
